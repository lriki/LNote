//=============================================================================
//【 GameSceneManager 】
//-----------------------------------------------------------------------------
///**
//  @file       GameSceneManager.h
//  @brief      GameSceneManager
//  @author     Riki
//*/
//=============================================================================

#pragma once

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
#include <queue>
#include <map>
#include "../../Core/Base/SharingKey.h"

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
namespace LNote
{
namespace Utility
{
class GameScene;

//=============================================================================
// ■ GameSceneManager クラス
//-----------------------------------------------------------------------------
///**
//  @brief     ゲームフレームワークの管理クラス
//*/
//=============================================================================
class GameSceneManager
    : public Core::Base::ReferenceObject
{
public:

    /// initialize() に渡す初期化データ
	struct InitData
	{
        Core::Base::LogFile*      LogFile;
        Core::Framework*          Framework;
        
        /// デフォルト値
        InitData()
            : LogFile       ( NULL )
            , Framework     ( NULL )
        {}
    };

public:

    /// コンストラクタ
	GameSceneManager();

	/// デストラクタ
    ~GameSceneManager();

public:

    //---------------------------------------------------------------------
    ///**
    //  @brief      初期化
    //*/
    //---------------------------------------------------------------------
    LNRESULT initialize( const InitData& data_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      終了処理
    //*/
    //---------------------------------------------------------------------
    void finalize();

    //---------------------------------------------------------------------
    ///**
    //  @brief      ゲームシーンのインスタンスを登録する
    //
    //  @retval     true  : 成功
    //  @retval     false : name_ が重複している
    //
    //  @par
    //              この関数は registerSceneInstance( new TestScene(), "TestScene" ); のような形で
    //              new したポインタを直接渡すことを想定しています。
    //              そのため、渡されたポインタは SceneManage で管理され、
    //              ゲームシーンが必要なくなった時点で release() が
    //              呼ばれます。
    //*/
    //---------------------------------------------------------------------
    bool registerSceneInstance( GameScene* scene_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      ゲームシーンの型を指定してインスタンスを登録する
    //
    //  @par
    //              この関数はポインタを隠蔽するための registerSceneInstance() です。
    //              registerSceneInstance< TestScene >( "TestScene" ); という形で呼び出します。
    //*/
    //---------------------------------------------------------------------
    template < typename TYPE_ > bool registerSceneInstance() { TYPE_* t = NEW TYPE_; return registSceneInstance( t ); }

    //---------------------------------------------------------------------
    ///**
    //  @brief      別のゲームシーンに変更する
    //
    //  @par
    //              pushScene() によって追加されたゲームシーンは、スタックの先頭から
    //              順に onTerminate() と release() を呼び出して終了させます。
    //*/
    //---------------------------------------------------------------------
    void changeScene( GameScene* next_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      別のゲームシーンに変更する
    //*/
    //---------------------------------------------------------------------
    void changeScene( const lnChar* scene_name_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      新しいゲームシーンをプッシュする
    //
    //  @par
    //              現在のゲームシーンの子として新しいゲームシーンを追加し、
    //              スタックの先頭に配置します。
    //              
    //              changeScene() で開始されたアクティブなシーンがない場合は何もしません。
    //
    //  @note
    //              1フレームの間に
    //              changeScene() → pushScene() の順で呼ぶと、新しいトップシーンの子として追加
    //              pushScene() → changeScene() の順で呼ぶと、子シーンは実行されないまま新しいトップシーンが始まる
    //*/
    //---------------------------------------------------------------------
    void pushScene( GameScene* scene_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      ゲームシーンをプッシュする
    //*/
    //---------------------------------------------------------------------
    void pushScene( const lnChar* scene_name_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      実行中のシーンを終了して親シーンへ戻る
    //
    //  @note
    //              親がない場合はなにもしない。
    //              この関数を呼び出すときに getActiveGameScene() で
    //              現在のシーンをチェックしておくと間違いが無くなる。
    //
    //              pushScene() 後、一度も update() が呼ばれないうちに
    //              この関数が呼ばれた場合、追加待ちシーンに対して操作が行われる。
    //
    //              scene_name_ を指定した場合はそのシーンが見つかるまで
    //              return を繰り返す。見つからなかった場合はなにもしない。
    //*/
    //---------------------------------------------------------------------
	void returnScene( const lnChar* scene_name_ = NULL );

    //---------------------------------------------------------------------
    ///**
    //  @brief      次のゲームシーンがあるか調べる
    //*/
    //---------------------------------------------------------------------
	bool isNextScene() const;

    //---------------------------------------------------------------------
    ///**
    //  @brief      実行中のゲームシーンを返す
    //
    //  @par
    //              スタックに複数のシーンがある場合はスタックの先頭のシーン
    //              (最後の pushScene() で追加されたシーン) を返します。
    //*/
    //---------------------------------------------------------------------
    GameScene* getActiveGameScene() { return mScene; }

    


    //---------------------------------------------------------------------
    ///**
    //  @brief      フレーム更新
    //
    //  @retval     true  : 実行中
    //  @retval     false : 実行するべきシーンがない、または終了した
    //
    //  @note
    //              必要があればゲームシーンの切り替えを行い、
    //              トップシーンの onUpdate() を呼ぶ。
    //*/
    //---------------------------------------------------------------------
	bool update();

    //---------------------------------------------------------------------
    ///**
    //  @brief      終了する
    //*/
    //---------------------------------------------------------------------
	void end();

private:

    /// 実行中のシーンを階層構造も含めて release する (changeScene() のために使う。全てのシーンのonTerminate() が呼ばれる。順番は子→親)
    void _releaseAllScene();

    /// 追加待ち子ツリーを全て release() する
    void _releaseAllAddedScene();

private:

    enum EventCommand
    {
        SMC_NONE = 0,       ///< 定義なし
        SMC_CHANGE,         ///< 直接遷移
        SMC_PUSH,           ///< 呼び出し
        SMC_RETURN,         ///< 呼び出し元へ戻る

/*
        SMC_CHANGE_LOADING,
        SMC_PUSH_LOADING
        */

    };

    struct EventMessage
    {
        EventCommand    Command;
        GameScene*      Scene;
    };

    
    typedef std::map< LSharingKey, GameScene* >  RegistedGameSceneMap;
    typedef std::pair< LSharingKey, GameScene* > RegistedGameScenePair;

private:

    GameScene*	    mScene;			    ///< 現在のゲームシーン
	GameScene*	    mNextScene;		    ///< 移動先のゲームシーン
    bool            mChangeRequested;   ///< シーン変更要求
	bool		    mEndRequested;	    ///< 終了要請
    Core::Framework*      mFramework;

    GameScene*      mShouldAddedScene;  ///< 次のフレームの開始時に子として追加するシーン (同時に複数追加する場合は一番子を指す。追加した後はすぐに NULL にしておく)

    RegistedGameSceneMap    mRegistedGameSceneMap;
    std::deque< EventMessage >      mMessageQueue;


    //std::stack< GameScene* >    mGameSceneStack;    ///< シーンのスタック (トップシーン (mScene) はスタックに追加しない)

    friend class    GameScene;
};

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------

} // namespace Utility
} // namespace LNote

//=============================================================================
//                              end of file
//=============================================================================