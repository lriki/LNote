//=============================================================================
//【 File 】
//-----------------------------------------------------------------------------
///**
//  @file       Interface.h
//  @brief      Interface
//  @author     Riki
//*/
//=============================================================================

#pragma once

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
#include <list>
#include "FileUtil.h"

//-------------------------------------------------------------------------
// 
//-------------------------------------------------------------------------
namespace LNote
{
namespace Core
{

/// ファイルへのアクセス方法
enum LNFileAccessMode
{
	LN_FILEACCESS_ARCHIVE_FIRST = 0,	    ///< アーカイブ優先
	LN_FILEACCESS_DIRECTORY_FIRST,		    ///< ディレクトリ優先
	LN_FILEACCESS_ARCHIVE_ONLY,			    ///< アーカイブのみ
};

/// アーカイブファイルのファイル名とキーの組み合わせ
struct LNArchiveOpenData
{
    ln_std_tstring  Directory;      ///< アーカイブファイルが保存されている実際のディレクトリ
    ln_std_tstring  ArchiveName;    ///< アーカイブファイルの名前
    ln_std_tstring  ArchiveKey;     ///< 暗号化アーカイブファイルを開くためのキー
};

typedef std::list< LNArchiveOpenData > LNArchiveOpenDataList;

/// 非同期処理の状態
enum LNASyncProcessState
{
    LN_ASYNCSTATE_WAIT = 0,     ///< 待機状態 (初期状態)
    LN_ASYNCSTATE_READY,        ///< 実行可能状態 (start() 後。キューに入っている状態)
    LN_ASYNCSTATE_PROCESSING,   ///< 実行状態 (処理中)
    LN_ASYNCSTATE_FINISH        ///< 終了状態 (処理終了後)
};

/// ファイルオープンモード
enum LNFileOpenMode
{
    LN_OPENMODE_BINARY = 0,     ///< バイナリモードで開く
    LN_OPENMODE_TEXT            ///< テキストモードで開く
};

} // namespace Core
} // namespace LNote

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
namespace LNote
{
namespace Core
{
namespace File
{
class IInFile;
class IOutFile;
class ASyncProcessObject;

//=============================================================================
// ■ IManager クラス
//-----------------------------------------------------------------------------
///**
//  @brief      ファイル入出力の管理インターフェイス
//*/
//=============================================================================
class IManager
    : public Base::Interface
{
public:

#if 0
    //---------------------------------------------------------------------
	///**
    //  @brief      読み込み用カレントパスの設定
    //
    //  @par
    //              基本的に相対パスで指定してください。
    //              絶対パスにすると、アーカイブ内の検索ができません。<br>
    //              <br>
    //              NULL を設定すると、カレントパスがクリアされてデフォルトのパスに戻ります。<br>
    //*/
    //---------------------------------------------------------------------
	virtual void setCurrentPath( const lnChar* directory_ ) = 0;
#endif

    

    //---------------------------------------------------------------------
	///**
    //  @brief      InFile の作成
    //
    //  @param[out] file_     : 作成されたオブジェクトを指すポインタ変数へのアドレス
    //  @param[in]  filename_ : ファイル名
    //
    //  @par
    //              アーカイブから読み込む場合、setCurrentDirectory() で設定した
    //              ディレクトリからの相対パスを渡す必要があります。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT createInFile( IInFile** file_, const lnChar* filename_, LNFileOpenMode mode_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      OutFile の作成
    //
    //  @param[out] file_     : 作成されたオブジェクトを指すポインタ変数へのアドレス
    //  @param[in]  filename_ : ファイル名
    //  @param[in]  buffer_   : 保存するデータが格納されているバッファのアドレス
    //  @param[in]  size_     : 保存するデータのサイズ (バイト単位)
    //
    //  @par
    //              OutFile 内部ではデータへのポインタのみを保持します。
    //              保存が完了するまで buffer_ のデータを解放しないでください。
    //*/		
	//---------------------------------------------------------------------
	virtual LNRESULT createOutFile( IOutFile** file_, const lnChar* filename_, const void* buffer_, int size_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      読み込み用カレントパスの移動
    //
    //  @par
    //              現在のカレントパスを記憶して、新しいパスを設定します。<br>
    //              必ず retrunCurrentPath() で復帰させてください。
    //*/
    //---------------------------------------------------------------------
	virtual void moveCurrentPath( const lnChar* directory_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      読み込み用カレントパスの復帰
    //*/
    //---------------------------------------------------------------------
	virtual void returnCurrentPath() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ファイルアクセスのロック
    //
    //  @par
    //              ファイルアクセスをする時の排他処理を開始します。<br>
    //              これはひとつの非同期処理の中で複数のファイルアクセスをする必要がある時に、
    //              別のスレッドからのカレントディレクトリの書き換えを防止するために使います。
    //*/
    //---------------------------------------------------------------------
	virtual void lock() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ファイルアクセスのアンロック
    //*/
    //---------------------------------------------------------------------
	virtual void unlock() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      非同期処理のリクエスト
    //*/
    //---------------------------------------------------------------------
	virtual void requestASyncProcess( ASyncProcessObject* obj_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      キューにある非同期処理のリクエストを外す
    //
    //  @par
    //              リクエストが実行中の場合は何もしません。
    //*/
    //---------------------------------------------------------------------
	virtual void removeASyncProcess( ASyncProcessObject* obj_ ) = 0;

    

protected:

    virtual ~IManager() {};
};

//=============================================================================
// ■ IInStream クラス
//-----------------------------------------------------------------------------
///**
//  @brief      入力ストリーム (読み込み専用) のインターフェイス
//*/
//=============================================================================
class IInStream
    : public Base::Interface
{
public:

	/// ファイルサイズの取得
	virtual int getSize() = 0;

	/// ファイルポインタの位置の取得
	virtual int getPosition() = 0;

    /// データの読み込み (read_size_ = -1 ですべてのデータを読み込む)
	virtual int read( void* buffer_, int buffer_size_, int read_size_ = -1 ) = 0;

	/// ファイルポインタの設定
	virtual void seek( int offset_, int origin_ = SEEK_SET ) = 0;

protected:

	virtual ~IInStream() {}
};

//=============================================================================
// ■ IInFile クラス
//-----------------------------------------------------------------------------
///**
//  @brief      非同期読み込み可能なファイルのインターフェイス
//*/
//=============================================================================
class IInFile
    : public IInStream
{
public:

    //---------------------------------------------------------------------
	///**
    //  @brief      ファイルの内容を全て読み込む
    //
    //  @param[in]  async_ : true を渡すと非同期で読み込む
    //
    //  @retval     LN_ERR_ASSERT : 読み込みが完了する前に関数が複数回呼ばれた ( 読み込みは継続しています )
    //
    //  @par
    //              内部にファイルサイズ分のメモリを確保し、そこにファイルの内容を
    //              全て読み込みます。データにアクセスする場合は getData() を使用してください。<br>
    //              確保されたメモリはデストラクタで解放されます。<br>
    //              <br>
    //              async_ に true を指定して呼び出した(非同期で読み込んだ)場合は 
    //              isLoadFinished() で完了したかを確認してください。<br>
    //              読み込み中にこのクラスを解放しようとした場合、読み込みが完了するまで
    //              デストラクタで待機します。
    //*/		
    //---------------------------------------------------------------------
	virtual void load( bool async_ = false ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      load() で読み込まれたデータの取得
    //
    //  @return     読み込まれたデータの先頭ポインタ
    //
    //  @par
    //              返すデータは isLoadFinished() が true を返すまで不定です。
    //              実際に読み込みが開始されるまでは NULL を返します。<br>
    //              <br>
    //              念のため読み込まれたデータの末尾には NULL をセットしています。<br>
    //              そのため、実際に確保されているバッファサイズは getSize() の値 + 1 です。
    //*/		
    //---------------------------------------------------------------------
	virtual void* getData() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      load() での非同期読み込みの完了を判定する
    //
    //  @retval     true  : 読み込みが完了している
    //  @retval     false : 読み込み中
    //*/		
    //---------------------------------------------------------------------
	virtual bool isLoadFinished() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      load() での読み込みでエラーが発生したかを判定する
    //
    //  @retval     true  : エラーが発生した
    //  @retval     false : 正常
    //*/		
    //---------------------------------------------------------------------
	virtual bool isError() = 0;

protected:

    virtual ~IInFile() {}
};

//=============================================================================
// ■ IOutFile クラス
//-----------------------------------------------------------------------------
///**
//  @brief     非同期書き込み可能なファイルのインターフェイス
//*/
//=============================================================================
class IOutFile
    : public Base::Interface
{
public:

	//---------------------------------------------------------------------
	///**
    //  @brief      データを保存する
    //
    //  @param[in]  async_ : true を渡すと非同期で保存する
    //
    //  @par
    //              IManager::createOutFile() で渡したデータを保存します。
    //*/		
	//---------------------------------------------------------------------
	virtual void save( bool async_ = false ) = 0;

	//---------------------------------------------------------------------
	///**
    //  @brief      save() での非同期書き込みの完了を判定する
    //
    //  @retval     true  : 書き込みが完了している
    //  @retval     false : 書き込み中
    //*/		
	//---------------------------------------------------------------------
	virtual bool isSaveFinished() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      save() での書き込みでエラーが発生したかを判定する
    //
    //  @retval     true  : エラーが発生した
    //  @retval     false : 正常
    //*/		
    //---------------------------------------------------------------------
	virtual bool isError() = 0;

protected:

    virtual ~IOutFile() {}
};

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------

} // namespace File
} // namespace Core
} // namespace LNote

//=============================================================================
//								end of file
//=============================================================================