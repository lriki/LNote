//=============================================================================
//【 Audio 】
//-----------------------------------------------------------------------------
///**
//  @file       Audio.h
//  @brief      Audio
//  @author     Riki
//*/
//=============================================================================

#pragma once

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
#include "../Base/SharingKey.h"
#include "../Geometry/Vector3.h"
#include "../File/Interface.h"
#include "Types.h"

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
namespace LNote
{
namespace Core
{
namespace Audio
{
class ISound;
class IGameAudio;
class IAudioDevice;
class IResourceManager;
class IAudioSource;
class IAudioPlayer;

/// 3D サウンドリスナー
struct LN3DSoundListener
{
    LVector3    Position;
    LVector3    Direction;
    LVector3    UpDirection;
    LVector3    Velocity;

    LN3DSoundListener()
        : Direction( 0, 0, 1.0f )
        , UpDirection( 0, 1.0f, 0 )
    {}
};

//=============================================================================
// ■ IManager クラス
//-----------------------------------------------------------------------------
///**
//  @brief      オーディオ機能の管理インターフェイス
//*/
//=============================================================================
class IManager
    : public Base::Interface
{
public:

    /// GameAudio クラスの取得
    virtual IGameAudio* getGameAudio() = 0;

    /// デバイスクラスの取得
    virtual IAudioDevice* getAudioDevice() = 0;

    /// リソース管理クラスの取得
    virtual IResourceManager* getResourceManager() = 0;

    /// ISound の作成 (stream_ = NULL でキーを使った検索だけ行う)
    virtual LNRESULT createSound( ISound** sound_, File::IInStream* stream_, LNSoundPlayType type_, bool enable_3d_, Base::SharingKey key_ ) = 0;

    /// ISound の作成 (ファイル名指定)
    virtual LNRESULT createSound( ISound** sound_, const lnChar* filename_, LNSoundPlayType type_, bool enable_3d_ ) = 0;

    /// ISound の作成 (IAudioSource 指定)
    virtual LNRESULT createSound( ISound** sound_, IAudioSource* source_, LNSoundPlayType type_, bool enable_3d_ ) = 0;

    /// グループの停止
    virtual void stopGroup( u32 group_ ) = 0;

protected:

    virtual ~IManager() {}
};

//=============================================================================
// ■ GameAudio クラス
//-----------------------------------------------------------------------------
///**
//	@brief      ゲーム用の音声の演奏を扱うクラス
//
//  @par
//              このクラスのインスタンスは Engine::Audio::Manager クラスから取得します。
//*/
//=============================================================================
class IGameAudio
    : public Base::Interface
{
public:

    //---------------------------------------------------------------------
	///**
    //  @brief      BGM を演奏する
    //
    //  @param[in]  filename_  : ファイル名
    //  @param[in]  volume_    : 音量   (  0 ～ 100 )
    //  @param[in]  pitch_     : ピッチ ( 50 ～ 200 )
    //  @param[in]  fade_time_ : フェードインにかける時間 ( ミリ秒 )
    //
    //  @par
    //              filename_ の音声ファイルを読み込んで BGM として演奏します。     <br>
    //              BGM はひとつだけ演奏することができ、ループ再生します。          <br>
    //              既に BGM が演奏されている場合は停止して、新しいBGMを演奏します。<br>
    //                                                                              <br>
    //              fade_time_ はフェードインにかける時間です。                     <br>
    //              他の BGM の演奏中にフェードインしようとした場合、               <br>
    //              演奏中の BGM とクロスフェードしながら演奏を開始します。         <br>
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playBGM( const lnChar* filename_, int volume_ = 100, int pitch_ = 100, int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      BGM の演奏を停止する
    //
    //  @param[in]  fade_time_ : フェードアウトにかける時間 ( ミリ秒 )
    //*/
    //---------------------------------------------------------------------
	virtual void stopBGM( int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      BGS ( 環境音 ) を演奏する
    //
    //  @param[in]  filename_  : ファイル名
    //  @param[in]  volume_    : 音量   (  0 ～ 100 )
    //  @param[in]  pitch_     : ピッチ ( 50 ～ 200 )
    //  @param[in]  fade_time_ : フェードインにかける時間 ( ミリ秒 )
    //
    //  @par
    //              BGM と同じ方法で再生されます。( ひとつだけ演奏、ループ再生 )    <br>
    //              BGS は BGM と同時に演奏することができ、ME ( 効果音楽 ) による   <br>
    //              影響を受けず、常に演奏されます。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playBGS( const lnChar* filename_, int volume_ = 100, int pitch_ = 100, int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      BGS の演奏を停止する
    //
    //  @param[in]  fade_time_ : フェードアウトにかける時間 ( ミリ秒 )
    //*/
    //---------------------------------------------------------------------
	virtual void stopBGS( int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      ME ( 効果音楽 ) を演奏する
    //
    //  @param[in]  filename_  : ファイル名
    //  @param[in]  volume_    : 音量   (  0 ～ 100 )
    //  @param[in]  pitch_     : ピッチ ( 50 ～ 200 )
    //
    //  @par
    //              filename_ の音声ファイルを読み込んで ME として演奏します。      <br>
    //              レベルアップやアイテム取得時のファンファーレ等の演奏に使います。<br>
    //              ME はひとつだけ演奏され、ループ再生はしません。
    //              既に ME が演奏されている場合、それは停止されます。             <br>
    //                                                                              <br>
    //              ME の演奏開始時に BGM が演奏されていた場合は BGM を 
    //              500 ミリ秒かけて一時停止させ、その後に ME の演奏を開始します。  <br>
    //              その場合、ME の演奏終了後に BGM の演奏を再開し、
    //              2000 ミリ秒かけて BGM をフェードインさせます。                  <br>
    //                                                                              <br>
    //              このフェードイン、フェードアウトにかける時間は
    //              setMEFadeState() によって設定することができます。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playME( const lnChar* filename_, int volume_ = 100, int pitch_ = 100 ) = 0;
    
    //---------------------------------------------------------------------
    ///**
    //  @brief      ME の演奏を停止する
    //
    //  @par
    //              BGM の一時停止中に ME を停止した場合は playME() の記述と
    //              同じように BGM をフェードインさせながら再開させます。
    //*/
    //---------------------------------------------------------------------
	virtual void stopME() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      SE を演奏する
    //
    //  @param[in]  filename_  : ファイル名
    //  @param[in]  volume_    : 音量   (  0 ～ 100 )
    //  @param[in]  pitch_     : ピッチ ( 50 ～ 200 )
    //
    //  @par
    //              filename_ の音声ファイルを読み込んで SE として演奏します。  <br>
    //              SE は同時に複数再生することができ、同じ音声を演奏した場合は
    //              重ねがけされて演奏されます。                                <br>
    //                                                                          <br>
    //              また、SE は必ずオンメモリで再生されます。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playSE( const lnChar* filename_, int volume_ = 100, int pitch_ = 100 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      SE を 3D 空間上で演奏する
    //
    //  @param[in]  filename_  : ファイル名
    //  @param[in]  position_  : 音源の位置
    //  @param[in]  volume_    : 音量   (  0 ～ 100 )
    //  @param[in]  pitch_     : ピッチ ( 50 ～ 200 )
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT playSE( const lnChar* filename_, const LVector3& position_, float distance, int volume_ = 100, int pitch_ = 100 ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      全ての SE の演奏を停止する
    //*/
    //---------------------------------------------------------------------
	virtual void stopSE() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      ME 演奏時の BGM のフェード時間を設定する
    //
    //  @param[in]  begin_ : ME 演奏開始時の BGM のフェードアウト時間 ( ミリ秒 )
    //  @param[in]  end_   : ME 演奏終了後の BGM のフェードイン時間 ( ミリ秒 )
    //
    //  @par
    //              -1 を指定した項目は値を変更しません。
    //*/
    //---------------------------------------------------------------------
    virtual void setMEFadeState( int begin_, int end_ ) = 0;


    //---------------------------------------------------------------------
	///**
    //  @brief      指定された ISound を BGM として演奏する
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playBGMFromSound( ISound* sound_, int volume_ = 100, int pitch_ = 100  , int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      指定された ISound を BGS として演奏する
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playBGSFromSound( ISound* sound_, int volume_ = 100, int pitch_ = 100  , int fade_time_ = 0 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      指定された ISound を ME として演奏する
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playMEFromSound( ISound* sound_, int volume_ = 100, int pitch_ = 100 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      指定された ISound を SE として演奏する
    //
    //  @par
    //              音声のコピーを作成して、それを演奏します。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT playSEFromSound( ISound* sound_, int volume_ = 100, int pitch_ = 100 ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      同名 BGM の演奏再開フラグの設定
    //
    //  @par
    //              playBGM で現在演奏中の BGM と同じファイル名 (またはサウンド) を、
    //              同じボリューム、ピッチで演奏しようとしたときに、そのまま演奏を続けるか、
    //              曲の先頭に戻って演奏しなおすかを設定します。
    //              デフォルトは false (演奏を続ける) です。
    //*/
    //---------------------------------------------------------------------
	virtual void setEnableBGMRestart( bool flag_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      同名 BGS の演奏再開フラグの設定
    //*/
    //---------------------------------------------------------------------
	virtual void setEnableBGSRestart( bool flag_ ) = 0;

protected:

    virtual ~IGameAudio() {}
};

//=============================================================================
// ■ ISound クラス
//-----------------------------------------------------------------------------
///**
//  @brief      音声とその再生を扱うクラスのインターフェース
//
//  @par
//              IAudioPlayer と IAudioSource のラッパーです。
//*/
//=============================================================================
class ISound
    : public Base::Interface
{
public:

	/// 音量の取得
	virtual int getVolume() = 0;

	/// 音量の設定
	virtual void setVolume( int volume_ ) = 0;

	/// ピッチの取得
	virtual int getPitch() = 0;

	/// ピッチの設定
	virtual void setPitch( int pitch_ ) = 0;

	///// 再生中かを判定する
	//virtual bool isPlaying() = 0;

	///// 一時停止中かを判定する
	//virtual bool isPausing() = 0;

    /// サウンドの状態を取得する
    virtual void getState( LNAudioPlayState* state_ ) = 0;

    /// ループ再生の有効設定
    virtual void loop( bool loop_ ) = 0;

    /// ループ再生が有効かを判定する
    virtual bool isLoop() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief		ループ領域の設定
    //
    //  @param[in]  begin_  : ループ領域の先頭位置 ( サンプル数単位 )
    //  @param[in]  length_ : ループ領域長さ ( サンプル数単位 )
    //
    //  @par
    //              begin_ と length_ に 0 を設定すると全体がループ領域になります。
    //*/
    //---------------------------------------------------------------------
	virtual void setLoopState( u32 begin_, u32 length_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      再生
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT play() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      停止
    //*/
    //---------------------------------------------------------------------
	virtual void stop() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      一時停止
    //
    //  @param[in]  is_pause_ : true の場合一時停止する (解除するには false を渡します)
    //*/
    //---------------------------------------------------------------------
	virtual void pause( bool is_pause_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      音量のフェード
    //
    //  @param[in]  target_volume_ : 変更先の音量
    //  @param[in]  time_          : フェードにかける時間 (ミリ秒)
    //  @param[in]  state_         : フェード完了後の動作の指定					
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT fadeVolume( int target_volume_, int time_, LNSoundFadeState state_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源かを判定する
    //*/
    //---------------------------------------------------------------------
    virtual bool is3DSound() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源としての位置を設定する
    //
    //  @param[in]  pos_ : 位置
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT setPosition( const LVector3& pos_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源としての位置を取得する
    //*/
    //---------------------------------------------------------------------
    virtual const LVector3& getPosition() = 0;

    /// 速度の設定
    virtual void setVelocity( const LVector3& pos_ ) = 0;

    /// 減衰距離の設定
    virtual void setMaxDistance( lnfloat distance ) = 0;

    /// 内部に持っている音声再生クラスの取得
    virtual IAudioPlayer* getAudioPlayer() = 0;

	virtual void setGroupFlag( u32 flag_ ) = 0;

    virtual u32 getGroupFlag() = 0;

protected:

    virtual ~ISound() {};
};



//=============================================================================
// ■ IAudioDevice クラス
//-----------------------------------------------------------------------------
///**
//  @brief      オーディオの管理クラスのインターフェース
//*/
//=============================================================================
class IAudioDevice
    : public Base::Interface
{
public:

    /// IAudioPlayer を作成する (type_ に LN_SOUNDPLAYTYPE_AUTO は指定できないので注意)
    virtual LNRESULT createAudioPlayer( IAudioPlayer** obj_, IAudioSource* source_, bool enable_3d_, LNSoundPlayType type_ ) = 0;

    /// 3Dサウンドリスナーの取得
    virtual LN3DSoundListener* get3DSoundListener() = 0;

    /// 更新 (更新スレッドから呼ばれる)
    virtual void update() = 0;

    /// 3D 空間の1メートル相当の距離の設定
    virtual lnfloat setMetreUnitDistance( lnfloat d ) = 0;

protected:

    virtual ~IAudioDevice() {};

};

//=============================================================================
// ■ IResourceManager クラス
//-----------------------------------------------------------------------------
///**
//  @brief      音声リソース管理のインターフェイス
//*/
//=============================================================================
class IResourceManager
    : public Base::Interface
{
public:

    //---------------------------------------------------------------------
    ///**
    //  @brief      キーに対応するオーディオソースを検索する
    //
    //  @param[out] obj_ : 見つかったオーディオソースのポインタを格納する変数のアドレス ( 見つからなかった場合は NULL が格納されます )
    //  @param[in]  key_ : 検索に使うキークラス
    //
    //  @par
    //              見つかった場合は参照カウントをひとつ増やして返します。
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT findAudioSource( IAudioSource** obj_, Base::SharingKey key_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      オーディオソースの作成
    //
    //  @param[out] obj_    : 作成したオーディオソースのポインタを格納する変数のアドレス
    //  @param[in]  stream_ : 入力ストリーム
    //  @param[in]  key_    : 音声データを共有する時に使うキー
    //
    //  @par
    //              作成できた場合、stream_ は AudioSource によって参照され、
    //              参照カウントがひとつ増えます。
    //              <br>
    //              正常に作成できた場合、stream_ のファイルポインタは先頭に戻ります。<br>
    //
    //  @attention
    //              キーを指定する場合は必ず findAudioSource() で、すでに存在しているか
    //              チェックしてください。重複が発生するとメモリリークします。
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT createAudioSource( IAudioSource** obj_, File::IInStream* stream_, Base::SharingKey key_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      キャッシュをクリアする
    //*/
    //---------------------------------------------------------------------
    virtual void clearCache() = 0;

protected:

    virtual ~IResourceManager() {}
};

//=============================================================================
// ■ IAudioPlayer クラス
//-----------------------------------------------------------------------------
///**
//  @brief      音声再生クラスのインターフェース
//*/
//=============================================================================
class IAudioPlayer
    : public Base::Interface
{
public:

    /// IAudioSource の取得
	virtual IAudioSource* getAudioSource() const = 0;

	/// 音量の取得
	virtual int getVolume() const = 0;

	/// 音量の設定
	virtual LNRESULT setVolume( int volume_ ) = 0;

	/// ピッチの取得
	virtual int getPitch() const = 0;

	/// ピッチの設定
	virtual LNRESULT setPitch( int pitch_ ) = 0;

    /// 再生したサンプル数の取得 ( Midi の場合はミュージックタイム )
    virtual u64 getPlayedSamples() const = 0;

    /// 再生中判定 (削除予定)
	virtual bool isPlaying() const = 0;

	// 一時停止中判定 (削除予定)
	virtual bool isPausing() const = 0;

    /// 再生状態の取得
    virtual LNSoundPlayState getPlayState() const = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ループ再生の有効設定
    //
    //  @param[in]  loop_ : ループ再生する場合、true を設定する
    //*/
    //---------------------------------------------------------------------
	virtual void loop( bool loop_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ループ再生が有効かを判定する
    //*/
    //---------------------------------------------------------------------
	virtual bool isLoop() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ループ情報の設定
    //
    //  @param[in]  loop_begin_  : ループされる領域の最初のサンプル
    //  @param[in]  loop_length_ : ループ領域の長さ (サンプル数単位)
    //   
    //  @par
    //              全体をループ再生する場合は loop_begin_ と loop_length_ に
    //              0 を設定してください。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT setLoopState( u32 loop_begin_, u32 loop_length_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief		再生
    //
    //  @note
    //              ・先頭から開始			<br>
    //              ・ポーズ解除			<br>
    //              ・フェード状態初期化	<br>
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT play() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      停止
    // 
    //  @note
    //              ・ポーズ解除
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT stop() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		一時停止
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT pause( bool is_pause_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      ポーリング更新
    // 
    //  @par
    //              再生終了(停止)している場合は true を返します。
    //              ループ再生の場合は常に true を返します。
    //*/
    //---------------------------------------------------------------------
	virtual bool polling() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源かを判定する
    //*/
    //---------------------------------------------------------------------
    virtual bool is3DSound() = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源としての位置を設定する
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT setPosition( const LVector3& pos_ ) = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief		3D 音源としての位置を取得する
    //*/
    //---------------------------------------------------------------------
    virtual const LVector3& getPosition() = 0;

    /// 速度の設定
    virtual void setVelocity( const LVector3& v ) = 0;

    /// 3D 音源の影響範囲 (音の届く距離) の設定
    virtual void setEmitterDistance( lnfloat distance_ ) = 0;

    /// 3D 音源の影響範囲 (音の届く距離) の取得
    virtual lnfloat getEmitterDistance() const = 0;

public:

	virtual ~IAudioPlayer() {}
};


//=============================================================================
// ■ IAudioSource クラス
//-----------------------------------------------------------------------------
///**
//  @brief      音声データのインターフェイス
//*/
//=============================================================================
class IAudioSource
    : public Base::Interface
{
public:

	/// ファイルフォーマットの取得
	virtual LNAudioSourceFormat getSourceFormat() const = 0;

	/// PCM フォーマットの取得
	virtual const LNWaveFormat* getWaveFormat() const = 0;

	/// 元データのサイズの取得 ( ストリーミング再生での終了判定等で使う )
	virtual u32 getSourceDataSize() const = 0;

	/// 全体の再生時間の取得 ( ミリ秒 後で無くなるかも )
	virtual u32 getTotalTime() const = 0;

    /// 全体のサンプル数の取得 ( Midi の場合はミュージックタイム単位 )
	virtual u32 getTotalUnits() const = 0;

	/// オンメモリ再生用のバッファの先頭アドレス取得 ( fillBufferAndReleaseStream() を呼んでいない場合は NULL )
	virtual u8* getOnmemoryPCMBuffer() const = 0;

	/// オンメモリ再生時の全バッファサイズの取得
	virtual u32 getOnmemoryPCMBufferSize() const = 0;

    //---------------------------------------------------------------------
	///**
    //	@brief      1 秒あたりのバイト数取得
    //
    //	@note
    //              通常は PCM フォーマットから取得できるけど、MP3 の場合は
    //              API の都合(?)上、デコードに最適な 1 秒分のサイズは、
    //              普通のPCMのそれとは異なる。
    //              そのため、ちゃんとチェックできるようにこのメソッドを用意。
    //              いまのところは MP3 に限った話だけど、getWaveFormat() で
    //              取得した値から 1 秒分のサイズを計算するとバグので注意。
    //*/
    //---------------------------------------------------------------------
	virtual u32 getBytesPerSec() const = 0;

    //---------------------------------------------------------------------
    ///**
    //  @brief      ループ開始位置と終了位置の取得
    //
    //  @par
    //              Midi ファイルの場合は最初の CC111 位置のデルタタイムとベースタイム
    //*/
    //---------------------------------------------------------------------
	virtual void getLoopState( u32* begin_, u32* length_ ) const = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      オーディオファイルとして扱うストリームを設定する
    //
    //  @par
    //              受け取ったストリームは参照カウントがひとつ増え、
    //              インスタンスが解放されるか fillBuffer() が呼ばれるまで保持されます。
    //              (解放されたときに参照カウントをデクリメント)
    //*/
    //---------------------------------------------------------------------
    virtual LNRESULT setStream( File::IInStream* stream_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      オンメモリ再生用に全てのデータを読み込む
    //
    //  @par
    //              デコード後の PCM データサイズ分のバッファを内部で確保し、
    //              そこに全てのデータを読み込みます。
    //              データ及びサイズは getOnmemoryPCMBuffer()、
    //              getOnmemoryPCMBufferSize() で取得してください。<br>
    //              <br>
    //              複数回呼ばれても、すでにバッファが確保されている場合は
    //              なにもしません。<br>
    //              <br>
    //              呼出し後、ストリームは解放され、このオーディオソースは
    //              ストリーミング再生には使用できなくなります。<br>
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT fillBufferAndReleaseStream() = 0;

    /// fillBufferAndReleaseStream() スレッドセーフ
    virtual void fillBufferSafe() = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      データをデコードし、buffer_ に書き込む
    //
    //  @param[out] buffer_         : PCM データを書き込むバッファ
    //  @param[in]  buffer_size_    : buffer_ のサイズ ( バイト単位 )
    //  @param[out] read_size_      : ソースデータから読み込んだデータサイズ
    //  @param[out] write_size_     : 実際に buffer_ に書き込んだサイズ
    //
    //  @par
    //              できるだけ buffer_size_ を満たすようにデータをデコードし、
    //              buffer_ 書き込みます。
    //              通常、buffer_size_ は getBytesPerSec() と同じ値です。<br>
    //              <br>
    //              read_size_ はデコードの為にソースから読み込んだデータサイズです。
    //              通常、mp3 等の圧縮フォーマットでは write_size_ よりも小さい値になります。
    //              現在のファイルポインタに read_size_ の値を足した値が、
    //              次回の読み込み位置となります。<br>
    //              <br>
    //              write_size_ は、通常は buffer_size_ と同じ値ですが、
    //              ファイル終端などでは buffer_size_ よりも小さい値 ( 音声データがあるところまで )
    //              になります。	
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT read( void* buffer_, u32 buffer_size_, u32* read_size_, u32* write_size_ ) = 0;

    //---------------------------------------------------------------------
	///**
    //  @brief      ファイルポインタ移動
    //
    //  @param[in]  offset_ : 移動量 ( バイト単位 )
    //
    //  @par
    //              ソースデータの先頭から offset_ 分移動したところに設定します。
    //*/
    //---------------------------------------------------------------------
	virtual LNRESULT seek( u32 offset_ ) = 0;

    /// seek + reed + スレッドセーフ
    virtual void readSafe( void* buffer_, u32 buffer_size_, u32 offset_, u32* read_size_, u32* write_size_ ) = 0;


    //---------------------------------------------------------------------
	///**
    //  @brief      デコード状態のリセット
    //
    //  @note
    //              新しく再生を開始する前に呼ぶこと。
    //              mp3 のソースクラスで実装される。
    //*/
    //---------------------------------------------------------------------
	virtual void reset() = 0;

protected:

	virtual ~IAudioSource() {}
};

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------

} // namespace Audio
} // namespace Core
} // namespace LNote

//=============================================================================
//								end of file
//=============================================================================