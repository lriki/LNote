//=============================================================================
//【 Math 】
//-----------------------------------------------------------------------------
///**
//  @file       Math.h
//  @brief      Math
//  @version    1.0
//  @date       2011/08/07
//*/
//=============================================================================

#pragma once

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
#if defined(LNOTE_MSVC)
#include <float.h>  // for _isnan   VC++用? 
#endif
#include "Enum.h"

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
namespace LNote
{
namespace Core
{

//=============================================================================
// ■ Math モジュール
//-------------------------------------------------------------------------
///**
//  @brief      算術関係のモジュール
//
//  @par
//              ◆ 三角関数テーブルについて<br><br>
//              
//              プログラム開始時に角度の精度を決め、あらかじめ必要な値を
//              全て計算してテーブル(配列)に格納しておくことで
//              三角関数からの値の取得の速度を上げることができます。<br><br>
//              
//              このため、標準の三角関数はラジアン角(実数値)の角度を渡して値を取得しますが、
//              このモジュールの三角関数は initialize() に渡した値を1周とする整数(インデックス角度)
//              から値を取得します。<br>
//              インデックス角度を使うものは関数名に Idx が付いています。
//*/
//=============================================================================
namespace Math
{
    


	const lnfloat PI = 3.1415926535897932384626433832795f;	///< 円周率

    const lnfloat PI_OVER2 = 1.5708f;


	//atan2Idx( y, x );// y/x = 比
	// 結果の単位は一周(2πラジアン)の1/65536です(例：直角は16384)

    //---------------------------------------------------------------------
	///**
    //  @brief      三角関数テーブルの初期化
    //
    //  @param[in]  precision_ : 角度の精度 ( 1 〜 65536 )
    //
    //  @retval     true  : 成功
    //  @retval     false : 失敗 ( precision_ の値が範囲外 )
    //
    //  @par
    //              このモジュールで使う三角関数 ( sinIdx() cosIdx() tanIdx() ) 
    //              のテーブルを初期化します。<br><br>
    //              
    //              precision_ に指定する値は1周の角度です。
    //              通常の度数法 ( 1周360度 ) であれば 360 を設定します。<br><br>
    //              
    //              ただし、特に大きなものを回転させようとする場合
    //              360 程度では荒さが目立ってしまう事があるため、
    //              できるだけ大きな値にすることをお勧めします。
    //              ( 360 を意識して使いたいのであれば 36000 等 )
    //*/
    //---------------------------------------------------------------------
	bool initializeTable( u32 precision_ );

    //---------------------------------------------------------------------
	///**
    //  @brief      sin
    //
    //  @param[in]  r_ : 角度 ( インデックス角度 )
    //*/
    //---------------------------------------------------------------------
	lnfloat sinIdx( int r_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      cos
    //
    //  @param[in]  r_ : 角度 ( インデックス角度 )
    //*/
    //---------------------------------------------------------------------
	lnfloat cosIdx( int r_ );

    //---------------------------------------------------------------------
    ///**
    //  @brief      tan
    //
    //  @param[in]  r_ : 角度 ( インデックス角度 )
    //*/
    //---------------------------------------------------------------------
	lnfloat tanIdx( int r_ );


	/// 角度 ( 度数法 )をラジアンに変換する
	inline float  DegToRad( float d_ )  { return d_ * 0.017453292519943295769236907684886f; }	// 0.017… は180 の逆数 * PI
	
    /// 角度 ( 度数法 )をラジアンに変換する
    inline double DegToRad( double d_ ) { return d_ * 0.017453292519943295769236907684886; }

	/// ラジアンを角度 ( 度数法 ) に変換する
	inline float  RadToDeg( float r_ )  { return r_ * 57.295779513082320876798154814105f; }		// 57.29… はPI の逆数 * 180
	
    /// ラジアンを角度 ( 度数法 ) に変換する
    inline double RadToDeg( double r_ ) { return r_ * 57.295779513082320876798154814105; }

    /// 小さい方を返す
    template < typename TYPE_ > TYPE_ min( TYPE_ a_, TYPE_ b_ ) { return ( a_ < b_ ) ? a_ : b_; } 

    /// 大きい方を返す
    template < typename TYPE_ > TYPE_ max( TYPE_ a_, TYPE_ b_ ) { return ( a_ > b_ ) ? a_ : b_; } 

    /// 値を範囲内に収める
    template < typename TYPE_ > TYPE_ limit( TYPE_ x_, TYPE_ min_, TYPE_ max_ ) { return ( x_ > max_ ) ? max_ : ( x_ < min_ ) ? min_ : x_; }

    /// v_ 以上の値をとる最小の2のべき乗数
    template < typename TYPE_ > TYPE_ pow2Paddiing( TYPE_ v_ )
    {
        TYPE_ v = 1;
        while ( v < v_ ) { v *= 2; }
        return v;
    }


#if defined(LNOTE_MSVC)
    /// 値が NaN かを判定する
    inline bool isNaN( float v_ ) { return _isnan( v_ ) != 0; }

    /// 値が NaN かを判定する
    inline bool isNaN( double v_ ) { return _isnan( v_ ) != 0; }

#else

    /// 値が NaN かを判定する
    inline bool isNaN( float v_ ) { return isnan( v_ ) != 0; }

    /// 値が NaN かを判定する
    inline bool isNaN( double v_ ) { return isnan( v_ ) != 0; }

    /// 値が INF かを判定する
    //inline bool isINF( float v_ ) { return isinf( v_ ) != 0; }

    /// 値が INF かを判定する
    //inline bool isINF( double v_ ) { return isinf( v_ ) != 0; }

#endif


    //---------------------------------------------------------------------
	///**
    //  @brief      線形補間
    //
    //  @param[in]	p0_	: 開始値
    //  @param[in]	p1_	: 終了値
    //  @param[in]	t_	: 補間値 ( 0.0 〜 1.0 )
    //
    //  @return		t_ における値
    //*/
    //---------------------------------------------------------------------
	inline static lnfloat linear( lnfloat p0_, lnfloat p1_, lnfloat t_ )
	{
		return p0_ + ( ( p1_ - p0_ ) * t_ );
	}

    //---------------------------------------------------------------------
    ///**
    //  @brief		等加速度運動
    //
    //	@param[in]	p_	: 開始値
    //	@param[in]	v_	: 初速度
    //	@param[in]	a_	: 加速度
    //  @param[in]	t_	: 時間
    //
    //	@return		t_ における値
    //*/
    //---------------------------------------------------------------------
    inline static lnfloat accel( lnfloat p_, lnfloat v_, lnfloat a_, lnfloat t_ )
    {
	    return p_ + ( v_ * t_ ) + ( 0.5f * a_ * t_ * t_ );
    }

    //---------------------------------------------------------------------
	///**
    //  @brief      三次補間
    //
    //  @param[in]	p0_	: 開始値
    //  @param[in]	p1_	: 終了値
    //  @param[in]	v0_	: 開始速度 ( 傾き )
    //  @param[in]	v1_	: 終了速度 ( 傾き )
    //  @param[in]	t_	: 補間値 ( 0.0 〜 1.0 )
    //
    //  @return		t_ における値
    //*/
    //---------------------------------------------------------------------
	inline static lnfloat cubic( lnfloat p0_, lnfloat p1_, lnfloat v0_, lnfloat v1_, lnfloat t_ )
	{
		lnfloat a = 2.f * ( p0_ - p1_ ) + ( v0_ + v1_ );
		lnfloat b = 3.f * ( p1_ - p0_ ) - ( 2.f * v0_ ) - v1_;
		lnfloat r = a;
		r *= t_;
		r += b;
		r *= t_;
		r += v0_;
		r *= t_;
		return r + p0_;
	}

    //---------------------------------------------------------------------
	///**
    //  @brief      Catmull-Rom 補間
    //
    //  @param[in]	p0_	: 第 1 通過点
    //  @param[in]	p1_	: 第 2 通過点
    //  @param[in]	p2_	: 第 3 通過点
    //  @param[in]	p3_	: 第 4 通過点
    //  @param[in]	t_	: 補間値 ( 0.0 〜 1.0 )
    //
    //  @return		t_ における値
    //
    //  @par
    //              t_ = 0.0 のときに p1_、t_ = 1.0 のときに p2_ が返ります。
    //*/
    //---------------------------------------------------------------------
	inline static lnfloat catmullRom( lnfloat p0_, lnfloat p1_, lnfloat p2_, lnfloat p3_, lnfloat t_ )
	{
		lnfloat v0 = ( p2_ - p0_ ) * 0.5f;
		lnfloat v1 = ( p3_ - p1_ ) * 0.5f;
		return ( 2.0f*p1_ - 2.0f*p2_ + v0 + v1 )*t_*t_*t_ +( -3.0f*p1_ + 3.0f*p2_ - 2.0f*v0 - v1 )*t_*t_ + v0*t_ + p1_;
	}


//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------

} // namespace Math
} // namespace Core

namespace LMath = Core::Math;

} // namespace LNote

//=============================================================================
//								end of file
//=============================================================================